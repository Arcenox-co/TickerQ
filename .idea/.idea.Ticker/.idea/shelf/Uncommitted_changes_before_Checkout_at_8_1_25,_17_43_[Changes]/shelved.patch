Index: Ticker.EntityFramework/Src/InternalTickerManager.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Microsoft.EntityFrameworkCore;\nusing NCrontab;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TickerQ.EntityFrameworkCore.Entities;\nusing TickerQ.Utilities;\nusing TickerQ.Utilities.Enums;\nusing TickerQ.Utilities.Interfaces;\n\nnamespace TickerQ.EntityFrameworkCore\n{\n    internal abstract class InternalTickerManager<TDbContext, TTimeTicker, TCronTicker> : IInternalTickerManager\n        where TDbContext : DbContext\n        where TTimeTicker : TimeTicker\n        where TCronTicker : CronTicker\n    {\n        protected readonly TDbContext DbContext;\n        protected readonly ITickerCollection TickerCollection;\n        protected readonly ITickerHost TickerHost;\n        protected readonly IClock Clock;\n        protected readonly TickerOptionsBuilder TickerOptionsBuilder;\n\n        /// <summary>\n        /// Identifies the machine/instance that locked the ticker.\n        /// </summary>\n        private string LockHolder => TickerOptionsBuilder.InstanceIdentifier ?? Environment.MachineName;\n\n        /// <summary>\n        /// Convenience accessors for DbSet\n        /// </summary>\n        public DbSet<TTimeTicker> TimeTickers => DbContext.Set<TTimeTicker>();\n        public DbSet<TCronTicker> CronTickers => DbContext.Set<TCronTicker>();\n        public DbSet<CronTickerOccurrence<TCronTicker>> CronTickerOccurrences => DbContext.Set<CronTickerOccurrence<TCronTicker>>();\n\n        #region Constructor\n\n        protected InternalTickerManager(\n            TDbContext dbContext,\n            ITickerCollection tickerCollection,\n            ITickerHost tickerHost,\n            IClock clock,\n            TickerOptionsBuilder tickerOptionsBuilder)\n        {\n            DbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));\n            TickerCollection = tickerCollection ?? throw new ArgumentNullException(nameof(tickerCollection));\n            TickerHost = tickerHost ?? throw new ArgumentNullException(nameof(tickerHost));\n            Clock = clock ?? throw new ArgumentNullException(nameof(clock));\n            TickerOptionsBuilder = tickerOptionsBuilder ?? throw new ArgumentNullException(nameof(tickerOptionsBuilder));\n        }\n\n        #endregion\n\n        #region Public Methods\n\n        /// <summary>\n        /// Gets the time until the next set of tickers (Time or Cron) and the list of functions that should run.\n        /// </summary>\n        public async Task<(TimeSpan TimeRemaining, (string, Guid, TickerType)[] Functions)> GetNextTickers(\n            CancellationToken cancellationToken = default)\n        {\n            var minCronTickerGroup = await GetEarliestCronTickerAsync(cancellationToken).ConfigureAwait(false);\n            var minTimeTickerDate = await GetEarliestTimeTickerAsync(cancellationToken).ConfigureAwait(false);\n\n            var timeRemaining = CalculateMinTimeRemaining(minCronTickerGroup, minTimeTickerDate);\n            if (timeRemaining == Timeout.InfiniteTimeSpan)\n            {\n                return (Timeout.InfiniteTimeSpan, Array.Empty<(string, Guid, TickerType)>());\n            }\n\n            var nextTickers = await GetNextTickersAsync(minCronTickerGroup, minTimeTickerDate, cancellationToken)\n                .ConfigureAwait(false);\n\n            return (timeRemaining, nextTickers);\n        }\n\n        /// <summary>\n        /// Sets the specified tickers to Inprogress status.\n        /// </summary>\n        public async Task SetTickersInprogress(\n            IEnumerable<(Guid TickerId, TickerType type)> resources,\n            CancellationToken cancellationToken = default)\n        {\n            var cronOccurrenceIds = resources\n                .Where(r => r.type == TickerType.CronExpression)\n                .Select(r => r.TickerId)\n                .Distinct()\n                .ToArray();\n\n            var timeTickerIds = resources\n                .Where(r => r.type == TickerType.Timer)\n                .Select(r => r.TickerId)\n                .Distinct()\n                .ToArray();\n\n            // Update Cron occurrences\n            if (cronOccurrenceIds.Any())\n            {\n                var cronOccurrences = await CronTickerOccurrences\n                    .Where(x => cronOccurrenceIds.Contains(x.Id))\n                    .ToListAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                foreach (var cronOccurrence in cronOccurrences)\n                {\n                    cronOccurrence.Status = TickerStatus.Inprogress;\n                }\n\n                DbContext.UpdateRange(cronOccurrences);\n            }\n\n            // Update Time tickers\n            if (timeTickerIds.Any())\n            {\n                var timeTickersList = await TimeTickers\n                    .Where(x => timeTickerIds.Contains(x.Id))\n                    .ToListAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                foreach (var timeTicker in timeTickersList)\n                {\n                    timeTicker.Status = TickerStatus.Inprogress;\n                }\n\n                DbContext.UpdateRange(timeTickersList);\n            }\n\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n        }\n\n        /// <summary>\n        /// Releases acquired (locked) resources and sets them back to Idle.\n        /// </summary>\n        public async Task ReleaseAcquiredResources(\n            IEnumerable<(Guid TickerId, TickerType type)> resources,\n            CancellationToken cancellationToken = default)\n        {\n            var cronOccurrenceIds = resources\n                .Where(r => r.type == TickerType.CronExpression)\n                .Select(r => r.TickerId)\n                .Distinct()\n                .ToArray();\n\n            var timeTickerIds = resources\n                .Where(r => r.type == TickerType.Timer)\n                .Select(r => r.TickerId)\n                .Distinct()\n                .ToArray();\n\n            // Release Cron occurrences\n            if (cronOccurrenceIds.Any())\n            {\n                var cronOccurrences = await CronTickerOccurrences\n                    .Where(x => cronOccurrenceIds.Contains(x.Id))\n                    .ToListAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                foreach (var occurrence in cronOccurrences)\n                {\n                    occurrence.Status = TickerStatus.Idle;\n                    occurrence.LockHolder = string.Empty;\n                    occurrence.LockedAt = default;\n                }\n\n                DbContext.UpdateRange(cronOccurrences);\n            }\n\n            // Release Time tickers\n            if (timeTickerIds.Any())\n            {\n                var timeTickersList = await TimeTickers\n                    .Where(x => timeTickerIds.Contains(x.Id))\n                    .ToListAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                foreach (var timeTicker in timeTickersList)\n                {\n                    timeTicker.Status = TickerStatus.Idle;\n                    timeTicker.LockHolder = null;\n                    timeTicker.LockedAt = default;\n                }\n\n                DbContext.UpdateRange(timeTickersList);\n            }\n\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n        }\n\n        /// <summary>\n        /// Updates the status of a ticker (Cron or Time).\n        /// </summary>\n        public async Task SetTickerStatus(\n            Guid tickerId,\n            TickerType tickerType,\n            TickerStatus tickerStatus,\n            CancellationToken cancellationToken = default)\n        {\n            if (tickerType == TickerType.CronExpression)\n            {\n                var cronOccurrence = await CronTickerOccurrences\n                    .Where(x => x.Id == tickerId)\n                    .FirstOrDefaultAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                if (cronOccurrence != null)\n                {\n                    cronOccurrence.Status = tickerStatus;\n                    cronOccurrence.ExcecutedAt = Clock.OffsetNow;\n                    DbContext.Update(cronOccurrence);\n                }\n            }\n            else\n            {\n                var timeTicker = await TimeTickers\n                    .Where(x => x.Id == tickerId)\n                    .FirstOrDefaultAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                if (timeTicker != null)\n                {\n                    timeTicker.Status = tickerStatus;\n                    timeTicker.ExcecutedAt = Clock.OffsetNow;\n                    DbContext.Update(timeTicker);\n                }\n            }\n\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n        }\n\n        /// <summary>\n        /// Retrieves the request payload for a given ticker.\n        /// </summary>\n        public async Task<T> GetRequest<T>(Guid tickerId, TickerType type, CancellationToken cancellationToken = default)\n        {\n            if (type == TickerType.CronExpression)\n            {\n                var cronTickerRequest = await CronTickerOccurrences\n                    .Include(x => x.CronTicker)\n                    .Where(x => x.Id == tickerId)\n                    .Select(x => x.CronTicker.Request)\n                    .FirstOrDefaultAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                return TickerHelper.ReadTickerRequest<T>(cronTickerRequest);\n            }\n            else\n            {\n                var timeTickerRequest = await TimeTickers\n                    .Where(x => x.Id == tickerId)\n                    .Select(x => x.Request)\n                    .FirstOrDefaultAsync(cancellationToken)\n                    .ConfigureAwait(false);\n\n                return TickerHelper.ReadTickerRequest<T>(timeTickerRequest);\n            }\n        }\n\n        /// <summary>\n        /// Finds time-out tickers that need to be forced into Inprogress (for retry logic).\n        /// </summary>\n        public async Task<(string, Guid, TickerType)[]> GetTimeoutedFunctions(CancellationToken cancellationToken = default)\n        {\n            var timedOutTimeTickers = await GetTimeoutedTimeTickersAsync(cancellationToken).ConfigureAwait(false);\n            var timedOutCronOccurrences = await GetTimeoutedCronTickerOccurrencesAsync(cancellationToken).ConfigureAwait(false);\n\n            if (!timedOutTimeTickers.Any() && !timedOutCronOccurrences.Any())\n            {\n                return Array.Empty<(string, Guid, TickerType)>();\n            }\n\n            // Save changes after marking them in progress.\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n\n            return timedOutTimeTickers.Concat(timedOutCronOccurrences).ToArray();\n        }\n\n        #endregion\n\n        #region Private Helpers\n\n        /// <summary>\n        /// Calculates the minimal time remaining among Cron/Time tickers.\n        /// </summary>\n        private TimeSpan CalculateMinTimeRemaining(IGrouping<DateTime, string> earliestCronGroup, DateTime earliestTimeTicker)\n        {\n            // If no Cron and no Time: no upcoming tickers => infinite\n            if (earliestCronGroup == default && earliestTimeTicker == default)\n                return Timeout.InfiniteTimeSpan;\n\n            var now = Clock.Now;\n\n            if (earliestCronGroup != default && earliestTimeTicker != default)\n            {\n                // Both exist => pick the earliest\n                var earliest = earliestCronGroup.Key < earliestTimeTicker\n                    ? earliestCronGroup.Key\n                    : earliestTimeTicker;\n                return earliest - now;\n            }\n            else if (earliestCronGroup != default)\n            {\n                // Only Cron\n                return earliestCronGroup.Key - now;\n            }\n            else\n            {\n                // Only Time\n                return earliestTimeTicker - now;\n            }\n        }\n\n        /// <summary>\n        /// Picks which group of tickers to fetch next (Time vs. Cron), or both if they occur close together.\n        /// </summary>\n        private async Task<(string, Guid, TickerType)[]> GetNextTickersAsync(\n            IGrouping<DateTime, string> earliestCronGroup,\n            DateTime earliestTimeTicker,\n            CancellationToken cancellationToken)\n        {\n            // If both are valid and occur within 5s of each other, fetch both sets.\n            if (earliestCronGroup != default &&\n                earliestTimeTicker != default &&\n                Math.Abs((earliestTimeTicker - earliestCronGroup.Key).TotalSeconds) <= 5)\n            {\n                var cronTickers = await AcquireNextCronTickersAsync(earliestCronGroup.ToArray(), cancellationToken);\n                var timeTickers = await AcquireNextTimeTickersAsync(earliestTimeTicker, cancellationToken);\n                return cronTickers.Union(timeTickers).ToArray();\n            }\n\n            // If no Cron -> Time only\n            if (earliestCronGroup == default)\n                return await AcquireNextTimeTickersAsync(earliestTimeTicker, cancellationToken);\n\n            // If no Time -> Cron only\n            if (earliestTimeTicker == default)\n                return await AcquireNextCronTickersAsync(earliestCronGroup.ToArray(), cancellationToken);\n\n            // Otherwise, whichever is earliest\n            return earliestTimeTicker < earliestCronGroup.Key\n                ? await AcquireNextTimeTickersAsync(earliestTimeTicker, cancellationToken)\n                : await AcquireNextCronTickersAsync(earliestCronGroup.ToArray(), cancellationToken);\n        }\n\n        /// <summary>\n        /// Fetches and locks the next Time tickers that are due (within 5s of <paramref name=\"minDate\"/>).\n        /// </summary>\n        private async Task<(string, Guid, TickerType)[]> AcquireNextTimeTickersAsync(\n            DateTimeOffset minDate,\n            CancellationToken cancellationToken)\n        {\n            var tolerance = TimeSpan.FromSeconds(5);\n\n            var dueTimeTickers = await TimeTickers\n                .Where(x => x.LockHolder == null && x.Status == TickerStatus.Idle)\n                .Where(x => x.ExecutionTime >= minDate && x.ExecutionTime <= minDate + tolerance)\n                .ToArrayAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            foreach (var ticker in dueTimeTickers)\n            {\n                ticker.Status = TickerStatus.Queued;\n                ticker.LockHolder = LockHolder;\n                ticker.LockedAt = Clock.OffsetNow;\n            }\n\n            DbContext.UpdateRange(dueTimeTickers);\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n\n            return dueTimeTickers\n                .Select(t => (t.Function, t.Id, TickerType.Timer))\n                .ToArray();\n        }\n\n        /// <summary>\n        /// Fetches and locks the next Cron tickers that match the given <paramref name=\"expressions\"/>.\n        /// </summary>\n        private async Task<(string, Guid, TickerType)[]> AcquireNextCronTickersAsync(\n            string[] expressions,\n            CancellationToken cancellationToken)\n        {\n            var now = Clock.Now;\n            var occurrencesToRun = new List<(string, Guid)>();\n\n            // Get Cron tickers with these expressions\n            var cronTickersList = await CronTickers\n                .AsNoTracking()\n                .Where(x => expressions.Contains(x.Expression))\n                .ToArrayAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            // Already-existing occurrences for these Cron tickers\n            var cronTickerIds = cronTickersList.Select(ct => ct.Id).ToArray();\n            var existingOccurrences = await CronTickerOccurrences\n                .Where(occ => cronTickerIds.Contains(occ.CronTickerId))\n                .ToListAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            foreach (var cronTicker in cronTickersList)\n            {\n                // Calculate next occurrence from now\n                var nextOccurrence = CrontabSchedule\n                    .Parse(cronTicker.Expression)\n                    .GetNextOccurrence(now);\n\n                // Check if there's an existing occurrence for that exact DateTime\n                var matchingOccurrence = existingOccurrences\n                    .FirstOrDefault(occ => occ.CronTickerId == cronTicker.Id &&\n                                            occ.ExecutionTime.DateTime == nextOccurrence);\n\n                if (matchingOccurrence == null)\n                {\n                    // Create new occurrence\n                    var newOccurrence = new CronTickerOccurrence<TCronTicker>\n                    {\n                        Id = Guid.NewGuid(),\n                        CronTickerId = cronTicker.Id,\n                        ExecutionTime = new DateTimeOffset(\n                            nextOccurrence,\n                            Clock.TimeZone.GetUtcOffset(DateTimeOffset.UtcNow)),\n                        LockedAt = Clock.OffsetNow,\n                        LockHolder = LockHolder,\n                        Status = TickerStatus.Queued\n                    };\n\n                    CronTickerOccurrences.Add(newOccurrence);\n                    occurrencesToRun.Add((cronTicker.Function, newOccurrence.Id));\n                }\n                else\n                {\n                    // Update existing\n                    matchingOccurrence.Status = TickerStatus.Queued;\n                    matchingOccurrence.LockHolder = LockHolder;\n                    matchingOccurrence.LockedAt = Clock.OffsetNow;\n                    CronTickerOccurrences.Update(matchingOccurrence);\n                    occurrencesToRun.Add((cronTicker.Function, matchingOccurrence.Id));\n                }\n            }\n\n            await DbContext.SaveChangesAsync(cancellationToken).ConfigureAwait(false);\n\n            return occurrencesToRun\n                .Select(x => (x.Item1, x.Item2, TickerType.CronExpression))\n                .ToArray();\n        }\n\n        /// <summary>\n        /// Gets the earliest scheduled time (in UTC) for a Time ticker that has not started and is not locked.\n        /// Returns DateTime.MinValue if none found.\n        /// </summary>\n        private async Task<DateTime> GetEarliestTimeTickerAsync(CancellationToken cancellationToken)\n        {\n            var now = Clock.OffsetNow;\n\n            var earliestOffset = await TimeTickers\n                .AsNoTracking()\n                .Where(x => x.LockHolder == null && x.Status == TickerStatus.Idle)\n                .Where(x => x.ExecutionTime > now)\n                .Select(x => x.ExecutionTime)\n                .DefaultIfEmpty(DateTimeOffset.MinValue)\n                .MinAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            return earliestOffset == DateTimeOffset.MinValue\n                ? default\n                : earliestOffset.DateTime;\n        }\n\n        /// <summary>\n        /// Gets the earliest next occurrence among all distinct Cron expressions.\n        /// Returns null if no Cron expressions exist.\n        /// </summary>\n        private async Task<IGrouping<DateTime, string>> GetEarliestCronTickerAsync(CancellationToken cancellationToken)\n        {\n            var now = Clock.Now;\n\n            var distinctExpressions = await CronTickers\n                .AsNoTracking()\n                .Select(x => x.Expression)\n                .Distinct()\n                .ToListAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            return distinctExpressions\n                .GroupBy(expr => CrontabSchedule.Parse(expr).GetNextOccurrence(now))\n                .OrderBy(g => g.Key)\n                .FirstOrDefault();\n        }\n\n        /// <summary>\n        /// Finds time-based tickers that have timed out and need to be retried (marked Inprogress).\n        /// </summary>\n        private async Task<IEnumerable<(string, Guid, TickerType)>> GetTimeoutedTimeTickersAsync(\n            CancellationToken cancellationToken)\n        {\n            var now = Clock.OffsetNow;\n            var threshold = TimeSpan.FromMinutes(TickerOptionsBuilder.TimeOutChecker.TotalMinutes);\n\n            var expiredTimeTickers = await TimeTickers\n                .Where(x => !x.ExcecutedAt.HasValue && x.Status != TickerStatus.Inprogress)\n                .Where(x => x.ExecutionTime.Add(threshold) <= now)\n                .ToArrayAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            if (!expiredTimeTickers.Any())\n                return Enumerable.Empty<(string, Guid, TickerType)>();\n\n            foreach (var timeTicker in expiredTimeTickers)\n            {\n                timeTicker.Status = TickerStatus.Inprogress;\n                timeTicker.LockHolder = LockHolder;\n            }\n\n            DbContext.UpdateRange(expiredTimeTickers);\n\n            return expiredTimeTickers.Select(x => (x.Function, x.Id, TickerType.Timer));\n        }\n\n        /// <summary>\n        /// Finds Cron ticker occurrences that have timed out and need to be retried (marked Inprogress).\n        /// </summary>\n        private async Task<IEnumerable<(string, Guid, TickerType)>> GetTimeoutedCronTickerOccurrencesAsync(\n            CancellationToken cancellationToken)\n        {\n            var now = Clock.OffsetNow;\n            var threshold = TimeSpan.FromMinutes(TickerOptionsBuilder.TimeOutChecker.TotalMinutes);\n\n            var expiredOccurrences = await CronTickerOccurrences\n                .Where(x => !x.ExcecutedAt.HasValue && x.Status != TickerStatus.Inprogress)\n                .Where(x => x.ExecutionTime.Add(threshold) <= now)\n                .ToArrayAsync(cancellationToken)\n                .ConfigureAwait(false);\n\n            if (!expiredOccurrences.Any())\n                return Enumerable.Empty<(string, Guid, TickerType)>();\n\n            foreach (var occurrence in expiredOccurrences)\n            {\n                occurrence.Status = TickerStatus.Inprogress;\n                occurrence.LockHolder = LockHolder;\n            }\n\n            DbContext.UpdateRange(expiredOccurrences);\n\n            // We’ll need to map the occurrence to its Cron ticker function name.\n            var cronTickerIds = expiredOccurrences.Select(x => x.CronTickerId).Distinct().ToArray();\n            var cronFunctions = await CronTickers\n                .AsNoTracking()\n                .Where(ct => cronTickerIds.Contains(ct.Id))\n                .Select(ct => new { ct.Id, ct.Function })\n                .ToListAsync(cancellationToken);\n\n            return expiredOccurrences.Select(occ =>\n            {\n                var matchingTicker = cronFunctions.First(cf => cf.Id == occ.CronTickerId);\n                return (matchingTicker.Function, occ.Id, TickerType.CronExpression);\n            });\n        }\n        #endregion\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Ticker.EntityFramework/Src/InternalTickerManager.cs b/Ticker.EntityFramework/Src/InternalTickerManager.cs
--- a/Ticker.EntityFramework/Src/InternalTickerManager.cs	(revision 5c93c1f8552ad8f634aa1ea4ca07f39ba00e4b90)
+++ b/Ticker.EntityFramework/Src/InternalTickerManager.cs	(date 1736350782472)
@@ -22,21 +22,11 @@
         protected readonly ITickerHost TickerHost;
         protected readonly IClock Clock;
         protected readonly TickerOptionsBuilder TickerOptionsBuilder;
-
-        /// <summary>
-        /// Identifies the machine/instance that locked the ticker.
-        /// </summary>
         private string LockHolder => TickerOptionsBuilder.InstanceIdentifier ?? Environment.MachineName;
-
-        /// <summary>
-        /// Convenience accessors for DbSet
-        /// </summary>
         public DbSet<TTimeTicker> TimeTickers => DbContext.Set<TTimeTicker>();
         public DbSet<TCronTicker> CronTickers => DbContext.Set<TCronTicker>();
         public DbSet<CronTickerOccurrence<TCronTicker>> CronTickerOccurrences => DbContext.Set<CronTickerOccurrence<TCronTicker>>();
-
-        #region Constructor
-
+        
         protected InternalTickerManager(
             TDbContext dbContext,
             ITickerCollection tickerCollection,
@@ -50,9 +40,7 @@
             Clock = clock ?? throw new ArgumentNullException(nameof(clock));
             TickerOptionsBuilder = tickerOptionsBuilder ?? throw new ArgumentNullException(nameof(tickerOptionsBuilder));
         }
-
-        #endregion
-
+        
         #region Public Methods
 
         /// <summary>
@@ -207,7 +195,7 @@
                 if (cronOccurrence != null)
                 {
                     cronOccurrence.Status = tickerStatus;
-                    cronOccurrence.ExcecutedAt = Clock.OffsetNow;
+                    cronOccurrence.ExecutedAt = Clock.OffsetNow;
                     DbContext.Update(cronOccurrence);
                 }
             }
@@ -221,7 +209,7 @@
                 if (timeTicker != null)
                 {
                     timeTicker.Status = tickerStatus;
-                    timeTicker.ExcecutedAt = Clock.OffsetNow;
+                    timeTicker.ExecutedAt = Clock.OffsetNow;
                     DbContext.Update(timeTicker);
                 }
             }
@@ -263,7 +251,7 @@
         public async Task<(string, Guid, TickerType)[]> GetTimeoutedFunctions(CancellationToken cancellationToken = default)
         {
             var timedOutTimeTickers = await GetTimeoutedTimeTickersAsync(cancellationToken).ConfigureAwait(false);
-            var timedOutCronOccurrences = await GetTimeoutedCronTickerOccurrencesAsync(cancellationToken).ConfigureAwait(false);
+            var timedOutCronOccurrences = await RetrieveTimedOutCronOccurrences(cancellationToken).ConfigureAwait(false);
 
             if (!timedOutTimeTickers.Any() && !timedOutCronOccurrences.Any())
             {
@@ -277,9 +265,7 @@
         }
 
         #endregion
-
-        #region Private Helpers
-
+        
         /// <summary>
         /// Calculates the minimal time remaining among Cron/Time tickers.
         /// </summary>
@@ -498,7 +484,7 @@
             var threshold = TimeSpan.FromMinutes(TickerOptionsBuilder.TimeOutChecker.TotalMinutes);
 
             var expiredTimeTickers = await TimeTickers
-                .Where(x => !x.ExcecutedAt.HasValue && x.Status != TickerStatus.Inprogress)
+                .Where(x => !x.ExecutedAt.HasValue && x.Status != TickerStatus.Inprogress)
                 .Where(x => x.ExecutionTime.Add(threshold) <= now)
                 .ToArrayAsync(cancellationToken)
                 .ConfigureAwait(false);
@@ -520,14 +506,14 @@
         /// <summary>
         /// Finds Cron ticker occurrences that have timed out and need to be retried (marked Inprogress).
         /// </summary>
-        private async Task<IEnumerable<(string, Guid, TickerType)>> GetTimeoutedCronTickerOccurrencesAsync(
+        private async Task<IEnumerable<(string, Guid, TickerType)>> RetrieveTimedOutCronOccurrences(
             CancellationToken cancellationToken)
         {
             var now = Clock.OffsetNow;
             var threshold = TimeSpan.FromMinutes(TickerOptionsBuilder.TimeOutChecker.TotalMinutes);
 
             var expiredOccurrences = await CronTickerOccurrences
-                .Where(x => !x.ExcecutedAt.HasValue && x.Status != TickerStatus.Inprogress)
+                .Where(x => !x.ExecutedAt.HasValue && x.Status != TickerStatus.Inprogress)
                 .Where(x => x.ExecutionTime.Add(threshold) <= now)
                 .ToArrayAsync(cancellationToken)
                 .ConfigureAwait(false);
@@ -557,6 +543,5 @@
                 return (matchingTicker.Function, occ.Id, TickerType.CronExpression);
             });
         }
-        #endregion
     }
 }
\ No newline at end of file
Index: Ticker/Src/FunctionHelper.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Microsoft.Extensions.DependencyInjection;\nusing NCrontab;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TickerQ.Utilities.Enums;\nusing TickerQ.Utilities.Interfaces;\n\nnamespace TickerQ\n{\n    internal static class TickerHelper\n    {\n        private static IInternalTickerManager GetInternalTickerManager(IServiceProvider serviceProvider)\n        {\n            using var scope = serviceProvider.CreateScope();\n            return scope.ServiceProvider.GetRequiredService<IInternalTickerManager>();\n        }\n\n        public static (TimeSpan, (string FunctionName, Guid TickerId, TickerType type)[]) GetNearestMemoryCronExpressions(IReadOnlyDictionary<string, string> memoryCronExpressions, DateTime now)\n        {\n            if (memoryCronExpressions.Count == 0)\n                return (Timeout.InfiniteTimeSpan, Array.Empty<(string, Guid, TickerType)>());\n\n            var nearestExpressions = new List<(string, Guid, TickerType)>();\n            var nearestTimeRemaining = TimeSpan.MaxValue;\n\n            foreach (var (functionName, cronExpression) in memoryCronExpressions)\n            {\n                var nextOccurrence = CrontabSchedule.Parse(cronExpression).GetNextOccurrence(now);\n                var timeRemaining = nextOccurrence - now;\n\n                if (timeRemaining < nearestTimeRemaining)\n                {\n                    nearestExpressions.Clear();\n                    nearestExpressions.Add((functionName, default, TickerType.CronExpression));\n                    nearestTimeRemaining = timeRemaining;\n                }\n                else if (timeRemaining == nearestTimeRemaining)\n                {\n                    nearestExpressions.Add((functionName, default, TickerType.CronExpression));\n                }\n            }\n\n            return (nearestTimeRemaining, nearestExpressions.ToArray());\n        }\n\n        public static async Task<(TimeSpan, (string FunctionName, Guid TickerId, TickerType type)[])> GetNearestOccurrenceFromDbAsync(IServiceProvider serviceProvider, CancellationToken cancellationToken = default)\n        {\n            var internalTickerManager = GetInternalTickerManager(serviceProvider);\n            return await internalTickerManager.GetNextTickers().ConfigureAwait(false);\n        }\n\n        public static async Task ReleaseAcquiredResourcesAsync(IServiceProvider serviceProvider, (string FunctionName, Guid TickerId, TickerType type)[] tickers, CancellationToken cancellationToken = default)\n        {\n            var internalTickerManager = GetInternalTickerManager(serviceProvider);\n            await internalTickerManager.ReleaseAcquiredResources(tickers.Select(x => (x.TickerId, x.type)), cancellationToken).ConfigureAwait(false);\n        }\n\n        public static async Task SetTickersInprogress(IServiceProvider serviceProvider, (string FunctionName, Guid TickerId, TickerType type)[] tickers, CancellationToken cancellationToken = default)\n        {\n            var internalTickerManager = GetInternalTickerManager(serviceProvider);\n            await internalTickerManager.SetTickersInprogress(tickers.Select(x => (x.TickerId, x.type)), cancellationToken).ConfigureAwait(false);\n        }\n\n        public static async Task SetTickerFinalStatus(IServiceScope scope, Guid tickerId, TickerType tickerType, TickerStatus tickerStatus, CancellationToken cancellationToken = default)\n        {\n            var internalTickerManager = scope.ServiceProvider.GetRequiredService<IInternalTickerManager>();\n            await internalTickerManager.SetTickerStatus(tickerId, tickerType, tickerStatus, cancellationToken);\n        }\n\n        public static async Task<(string FunctionName, Guid TickerId, TickerType type)[]> GetTimeoutedFunctions(IServiceProvider serviceProvider, CancellationToken cancellationToken = default)\n        {\n            var internalTickerManager = GetInternalTickerManager(serviceProvider);\n            return await internalTickerManager.GetTimeoutedFunctions(cancellationToken).ConfigureAwait(false);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Ticker/Src/FunctionHelper.cs b/Ticker/Src/FunctionHelper.cs
--- a/Ticker/Src/FunctionHelper.cs	(revision 5c93c1f8552ad8f634aa1ea4ca07f39ba00e4b90)
+++ b/Ticker/Src/FunctionHelper.cs	(date 1736350782480)
@@ -49,7 +49,7 @@
         public static async Task<(TimeSpan, (string FunctionName, Guid TickerId, TickerType type)[])> GetNearestOccurrenceFromDbAsync(IServiceProvider serviceProvider, CancellationToken cancellationToken = default)
         {
             var internalTickerManager = GetInternalTickerManager(serviceProvider);
-            return await internalTickerManager.GetNextTickers().ConfigureAwait(false);
+            return await internalTickerManager.GetNextTickers(cancellationToken).ConfigureAwait(false);
         }
 
         public static async Task ReleaseAcquiredResourcesAsync(IServiceProvider serviceProvider, (string FunctionName, Guid TickerId, TickerType type)[] tickers, CancellationToken cancellationToken = default)
Index: Ticker.EntityFramework/Entities/CronTickerOccurrence.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\nusing TickerQ.Utilities.Enums;\n\nnamespace TickerQ.EntityFrameworkCore.Entities\n{\n    public class CronTickerOccurrence<TCronTicker> where TCronTicker : CronTicker\n    {\n        public Guid Id { get; set; }\n        public TickerStatus Status { get; set; }\n        public string LockHolder { get; set; }\n        public DateTimeOffset ExecutionTime { get; set; }\n        public Guid CronTickerId { get; set; }\n        public DateTimeOffset? LockedAt { get; set; }\n        public DateTimeOffset? ExcecutedAt { get; set; }\n        public TCronTicker CronTicker { get; set; }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Ticker.EntityFramework/Entities/CronTickerOccurrence.cs b/Ticker.EntityFramework/Entities/CronTickerOccurrence.cs
--- a/Ticker.EntityFramework/Entities/CronTickerOccurrence.cs	(revision 5c93c1f8552ad8f634aa1ea4ca07f39ba00e4b90)
+++ b/Ticker.EntityFramework/Entities/CronTickerOccurrence.cs	(date 1736350782475)
@@ -11,7 +11,7 @@
         public DateTimeOffset ExecutionTime { get; set; }
         public Guid CronTickerId { get; set; }
         public DateTimeOffset? LockedAt { get; set; }
-        public DateTimeOffset? ExcecutedAt { get; set; }
+        public DateTimeOffset? ExecutedAt { get; set; }
         public TCronTicker CronTicker { get; set; }
     }
 }
