name: Build NuGet Packages

on:
  push:
    branches:
      - net8

jobs:
  check-nuget:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.check.outputs.all_exist }}
      version: ${{ steps.get-version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Read version from file
        id: get-version
        run: |
          VERSION=$(dotnet build src/TickerQ/TickerQ.csproj --getProperty:Version)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Check if all NuGet packages already exist
        id: check
        run: |
          VERSION="${{ steps.get-version.outputs.version }}"
          PACKAGE_IDS=(tickerq tickerq.dashboard tickerq.utilities tickerq.entityframeworkcore tickerq.instrumentation.opentelemetry tickerq.caching.stackexchangeredis)
          MISSING=0

          for ID in "${PACKAGE_IDS[@]}"; do
            LOWER_ID=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
            URL="https://api.nuget.org/v3-flatcontainer/$LOWER_ID/$VERSION/$LOWER_ID.$VERSION.nupkg"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")

            if [ "$STATUS" = "200" ]; then
              echo "âœ… $ID $VERSION exists on NuGet"
            else
              echo "âŒ $ID $VERSION does NOT exist on NuGet"
              MISSING=1
            fi
          done

          if [ "$MISSING" = "0" ]; then
            echo "all_exist=true" >> $GITHUB_OUTPUT
          else
            echo "all_exist=false" >> $GITHUB_OUTPUT
          fi

  build:
    needs: check-nuget
    if: needs.check-nuget.outputs.skip != 'true'
    runs-on: ubuntu-latest
    env:
      DOTNET_NOLOGO: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        run: npm install
        working-directory: src/TickerQ.Dashboard/wwwroot

      - name: Build frontend
        run: npm run build
        working-directory: src/TickerQ.Dashboard/wwwroot

      - name: Build TickerQ.Utilities
        run: dotnet build src/TickerQ.Utilities/TickerQ.Utilities.csproj --configuration Release

      - name: Pack TickerQ.Utilities
        run: dotnet pack src/TickerQ.Utilities/TickerQ.Utilities.csproj --configuration Release --output ./nupkgs

      - name: Add local nupkgs source
        run: dotnet nuget add source "$(pwd)/nupkgs" --name LocalNupkgs

      - name: Restore packages with local source
        run: dotnet restore

      - name: Build TickerQ.SourceGenerator
        run: dotnet build src/TickerQ.SourceGenerator/TickerQ.SourceGenerator.csproj --configuration Release

      - name: Build other projects
        run: |
          dotnet build src/TickerQ/TickerQ.csproj --configuration Release
          dotnet build src/TickerQ.EntityFrameworkCore/TickerQ.EntityFrameworkCore.csproj --configuration Release
          dotnet build src/TickerQ.Dashboard/TickerQ.Dashboard.csproj --configuration Release
          dotnet build src/TickerQ.Instrumentation.OpenTelemetry/TickerQ.Instrumentation.OpenTelemetry.csproj --configuration Release
          dotnet build src/TickerQ.Caching.StackExchangeRedis/TickerQ.Caching.StackExchangeRedis.csproj --configuration Release

      - name: Pack other projects
        run: |
          dotnet pack src/TickerQ/TickerQ.csproj --configuration Release --output ./nupkgs
          dotnet pack src/TickerQ.EntityFrameworkCore/TickerQ.EntityFrameworkCore.csproj --configuration Release --output ./nupkgs
          dotnet pack src/TickerQ.Dashboard/TickerQ.Dashboard.csproj --configuration Release --output ./nupkgs
          dotnet pack src/TickerQ.Instrumentation.OpenTelemetry/TickerQ.Instrumentation.OpenTelemetry.csproj --configuration Release --output ./nupkgs
          dotnet pack src/TickerQ.Caching.StackExchangeRedis/TickerQ.Caching.StackExchangeRedis.csproj --configuration Release --output ./nupkgs

      - name: Show .nupkg file sizes
        run: |
          echo "ðŸ“¦ Package sizes:"
          for pkg in ./nupkgs/*.nupkg; do
            size=$(du -h "$pkg" | cut -f1)
            echo " - $(basename "$pkg"): $size"
          done

      - name: Upload nupkgs artifact
        uses: actions/upload-artifact@v4
        with:
          name: nupkgs
          path: ./nupkgs

  trigger-publish:
    needs:
      - check-nuget
      - build
    # Allow this job to run even if build is skipped
    if: always() && needs.check-nuget.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Get artifact ID for nupkgs
        id: get_artifact
        # Only try to get artifact if build actually ran
        if: needs.build.result == 'success'
        run: |
          artifacts=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts)
          id=$(echo "$artifacts" | jq '.artifacts[] | select(.name=="nupkgs") | .id')
          echo "ARTIFACT_ID=$id" >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Trigger publish.yml with artifact ID
        # Only trigger publish if build succeeded and created artifact
        if: needs.build.result == 'success'
        uses: actions/github-script@v7
        env:
          GH_PAT: ${{ secrets.PAT_TOKEN }}
        with:
          script: |
            const artifactId = process.env.ARTIFACT_ID;
            const version = '${{ needs.check-nuget.outputs.version }}';

            const res = await fetch('https://api.github.com/repos/${{ github.repository }}/actions/workflows/publish.yml/dispatches', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.GH_PAT}`,
                'Accept': 'application/vnd.github.v3+json'
              },
              body: JSON.stringify({
                ref: 'main',
                inputs: {
                  version: version,
                  artifact_id: artifactId
                }
              })
            });

            if (!res.ok) {
              const body = await res.text();
              core.setFailed(`âŒ Failed to dispatch: ${res.status} ${res.statusText}\n${body}`);
            } else {
              console.log(`âœ… Successfully triggered publish with artifact ID: ${artifactId}`);
            }

      - name: Send Discord Notification
        if: always()
        run: |
          # Safely handle the commit message
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          BRANCH="${GITHUB_REF#refs/heads/}"

          if [[ "${{ github.event.head_commit.message }}" =~ ^Merge\ pull\ request ]]; then
            PR_BRANCH=$(echo "${{ github.event.head_commit.message }}" | sed -n "s/Merge pull request #[0-9]\+ from [^/]*\/\(.*\)/\1/p")
            MESSAGE="ðŸ“¦ *${REPO_NAME}* | Branch: \`${BRANCH}\` | Merged from: \`${PR_BRANCH}\`"
          else
            # Use a shortened commit message to avoid issues
            SHORT_MSG=$(echo "${{ github.event.head_commit.message }}" | head -n1)
            MESSAGE="ðŸ“¦ *${REPO_NAME}* | Branch: \`${BRANCH}\` | Commit: \`${SHORT_MSG}\`"
          fi

          # Determine status based on check-nuget and build results
          if [ "${{ needs.check-nuget.result }}" != "success" ]; then
            STATUS_EMOJI="âŒ"
            STATUS_TEXT="Failed"
            COLOR="15158332"
          elif [ "${{ needs.build.result }}" == "skipped" ]; then
            STATUS_EMOJI="â­ï¸"
            STATUS_TEXT="Skipped (Packages already exist)"
            COLOR="16776960"
          elif [ "${{ needs.build.result }}" != "success" ]; then
            STATUS_EMOJI="âŒ"
            STATUS_TEXT="Build Failed"
            COLOR="15158332"
          else
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="Successful"
            COLOR="3066993"
          fi

          # Create a proper JSON payload in a separate file
          cat > payload.json << EOF
          {
            "embeds": [
              {
                "title": "${STATUS_EMOJI} TickerQ Deployment ${STATUS_TEXT}",
                "description": "${MESSAGE}",
                "color": ${COLOR},
                "fields": [
                  {
                    "name": "Version",
                    "value": "${{ needs.check-nuget.outputs.version }}",
                    "inline": true
                  },
                  {
                    "name": "Build Status",
                    "value": "${{ needs.build.result }}",
                    "inline": true
                  }
                ],
                "footer": {
                  "text": "Deployed on $(date +'%Y-%m-%d %H:%M UTC')"
                }
              }
            ]
          }
          EOF

          # Send with the file as payload
          curl -H "Content-Type: application/json" \
            -X POST "${{ secrets.DISCORD_WEBHOOK }}" \
            --data @payload.json
