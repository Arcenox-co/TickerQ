name: Sync Version Branches

on:
  push:
    branches:
      - main
      - net8  # Allows manual pushes to net8 to be visible, but sync logic only runs from main
  workflow_dispatch:
    inputs:
      target_branches:
        description: 'Comma-separated list of target branches (default: net8)'
        required: false
        default: 'net8'
        type: string
      dry_run:
        description: 'Run without making changes'
        required: false
        default: false
        type: boolean

jobs:
  sync-branches:
    runs-on: ubuntu-latest

    permissions:
      contents: write      # Required to push commits to the repository
      pull-requests: write # Required to create pull requests
      issues: write        # Required to create and manage labels

    # Only run sync logic when triggered from main branch (prevents infinite loops)
    if: github.ref == 'refs/heads/main'

    strategy:
      matrix:
        target_branch: ${{ fromJSON(vars.TARGET_BRANCHES || '["net8"]') }}
      fail-fast: false

    steps:
      - name: Check PAT_TOKEN exists
        run: |
          if [ -z "${{ secrets.PAT_TOKEN }}" ]; then
            echo "‚ùå ERROR: PAT_TOKEN secret is not configured!"
            echo "Please add a Personal Access Token with 'repo' scope to repository secrets."
            echo "Go to: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret"
            echo "Name: PAT_TOKEN"
            echo "Value: Your GitHub Personal Access Token"
            exit 1
          fi
          echo "‚úÖ PAT_TOKEN is configured"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}
          persist-credentials: true

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Configure git to use the PAT for authentication
          git config --global url."https://${{ secrets.PAT_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: Extract target branches from input
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ -n "${{ github.event.inputs.target_branches }}" ]; then
            echo "TARGET_BRANCHES=[$(echo '${{ github.event.inputs.target_branches }}' | sed 's/,/","/g' | sed 's/^/"/;s/$/"/')]" >> $GITHUB_ENV
          fi

      - name: Check if merge is needed
        id: check_merge
        run: |
          echo "üîç Checking if merge is needed for ${{ matrix.target_branch }}"

          # Check if target branch exists
          if ! git ls-remote --heads origin ${{ matrix.target_branch }} | grep -q ${{ matrix.target_branch }}; then
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå Target branch ${{ matrix.target_branch }} does not exist"
            exit 0
          fi

          # Check if main has new commits
          git checkout main
          git checkout ${{ matrix.target_branch }}

          if git merge-base --is-ancestor main ${{ matrix.target_branch }}; then
            echo "needs_merge=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No new commits to merge"
          else
            echo "needs_merge=true" >> $GITHUB_OUTPUT
            echo "‚úÖ New commits found, merge needed"
          fi

      - name: Create sync branch and apply changes
        if: steps.check_merge.outputs.needs_merge == 'true'
        run: |
          echo "üîÑ Creating sync branch from ${{ matrix.target_branch }}"

          # Create a new branch for the PR
          sync_branch="sync-main-to-${{ matrix.target_branch }}-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$sync_branch" ${{ matrix.target_branch }}

          # Get the commits that need to be applied
          commits_to_apply=$(git log "${{ matrix.target_branch }}..main" --oneline --no-merges | cut -d' ' -f1 | tac)

          if [ -n "$commits_to_apply" ]; then
            echo "üìã Commits to apply: $commits_to_apply"

            # Track successful and failed cherry-picks
            successful_commits=()
            failed_commits=()
            applied_via_diff=()
            
            # Cherry-pick each commit individually to avoid merge conflicts
            for commit in $commits_to_apply; do
              echo "üçí Cherry-picking $commit..."
              if git cherry-pick --no-commit "$commit"; then
                echo "‚úÖ Cherry-pick successful for $commit"
                successful_commits+=("$commit")
              else
                echo "‚ö†Ô∏è  Cherry-pick failed for $commit, trying alternative method..."
                git cherry-pick --abort || true
                git reset --hard HEAD
                
                # Try to apply the diff manually (excluding .csproj files)
                echo "üìù Attempting to apply diff manually for $commit (excluding .csproj files)..."
                
                # Get list of files changed in this commit
                commit_files=$(git diff-tree --no-commit-id --name-only -r "$commit")
                
                # Check if commit only affects .csproj files
                csproj_only=true
                for file in $commit_files; do
                  if [[ ! "$file" =~ \.csproj$ ]]; then
                    csproj_only=false
                    break
                  fi
                done
                
                if [ "$csproj_only" = true ]; then
                  echo "‚ÑπÔ∏è  Commit $commit only affects .csproj files, skipping (will preserve target branch .csproj)"
                  failed_commits+=("$commit (csproj-only, preserved from target branch)")
                else
                  # Try to apply the diff, excluding .csproj files
                  # First, get the diff excluding .csproj files
                  if git show "$commit" --format=format: -- . ':!*.csproj' > /tmp/commit_diff.patch 2>/dev/null; then
                    # Check if there's actual content (not just empty)
                    if [ -s /tmp/commit_diff.patch ]; then
                      # Try to apply the patch
                      if git apply --index --ignore-whitespace /tmp/commit_diff.patch 2>/dev/null; then
                        echo "‚úÖ Successfully applied diff manually for $commit (excluding .csproj)"
                        applied_via_diff+=("$commit")
                        successful_commits+=("$commit")
                      else
                        # Try with 3-way merge strategy
                        echo "üìù Trying 3-way merge for $commit..."
                        if git apply --index --3way --ignore-whitespace /tmp/commit_diff.patch 2>/dev/null; then
                          echo "‚úÖ Successfully applied diff with 3-way merge for $commit"
                          applied_via_diff+=("$commit")
                          successful_commits+=("$commit")
                        else
                          # Last resort: try to manually apply file by file
                          echo "üìù Trying file-by-file application for $commit..."
                          applied_any=false
                          for file in $commit_files; do
                            if [[ ! "$file" =~ \.csproj$ ]]; then
                              # Try to get the file content from the commit
                              if git show "$commit:$file" > /tmp/commit_file 2>/dev/null; then
                                # Check if file exists in current branch
                                if [ -f "$file" ]; then
                                  # Try to merge the changes
                                  if git checkout "$commit" -- "$file" 2>/dev/null; then
                                    echo "  ‚úÖ Applied $file from commit $commit"
                                    applied_any=true
                                  fi
                                else
                                  # File doesn't exist, create it
                                  mkdir -p "$(dirname "$file")"
                                  cp /tmp/commit_file "$file"
                                  git add "$file"
                                  echo "  ‚úÖ Created $file from commit $commit"
                                  applied_any=true
                                fi
                              fi
                            fi
                          done
                          
                          if [ "$applied_any" = true ]; then
                            echo "‚úÖ Successfully applied changes file-by-file for $commit"
                            applied_via_diff+=("$commit")
                            successful_commits+=("$commit")
                          else
                            echo "‚ùå Could not apply commit $commit - will need manual review"
                            failed_commits+=("$commit")
                          fi
                        fi
                      fi
                      rm -f /tmp/commit_diff.patch /tmp/commit_file
                    else
                      echo "‚ÑπÔ∏è  Commit $commit has no changes after excluding .csproj files"
                      failed_commits+=("$commit (no changes after excluding .csproj)")
                    fi
                  else
                    echo "‚ùå Could not extract diff for $commit - will need manual review"
                    failed_commits+=("$commit")
                  fi
                fi
              fi
            done

            # Report on results
            echo ""
            echo "üìä Commit Application Summary:"
            echo "‚úÖ Successfully applied: ${#successful_commits[@]} commits"
            if [ ${#applied_via_diff[@]} -gt 0 ]; then
              echo "  - Applied via cherry-pick: $(( ${#successful_commits[@]} - ${#applied_via_diff[@]} )) commits"
              echo "  - Applied via alternative method: ${#applied_via_diff[@]} commits"
            fi
            if [ ${#failed_commits[@]} -gt 0 ]; then
              echo "‚ö†Ô∏è  Could not apply: ${#failed_commits[@]} commits"
              echo "Failed commits:"
              for failed in "${failed_commits[@]}"; do
                echo "  - $failed"
              done
            fi

            # Reset files that should stay as they are in the target branch
            echo "üìù Processing configuration files..."
            
            # Reset all .csproj files
            find . -name "*.csproj" -type f -exec git checkout ${{ matrix.target_branch }} -- {} \;
            
            # Get Directory.Build.props from main and update it for net8
            if [ -f "src/Directory.Build.props" ]; then
              echo "üìù Getting Directory.Build.props from main and updating for ${{ matrix.target_branch }}..."
              
              # Explicitly get the file from main branch
              git checkout main -- src/Directory.Build.props
              
              # Get the target .NET version
              dotnet_version=$(echo "${{ matrix.target_branch }}" | sed 's/[^0-9]*//g')
              
              # Show current state from main
              echo "Directory.Build.props from main (before update):"
              grep -E "<Version>|<TargetFramework>" src/Directory.Build.props
              
              # Update version (9.x.x ‚Üí 8.x.x) keeping the same minor/patch/suffix
              current_version=$(grep -oP '<Version>\K[^<]+' src/Directory.Build.props)
              new_version=$(echo "$current_version" | sed "s/^9\./$dotnet_version./")
              sed -i "s|<Version>$current_version</Version>|<Version>$new_version</Version>|g" src/Directory.Build.props
              
              # Update target framework (net9.0 ‚Üí net8.0)
              sed -i "s|<TargetFramework>net9\.0</TargetFramework>|<TargetFramework>net$dotnet_version.0</TargetFramework>|g" src/Directory.Build.props
              
              echo "Directory.Build.props after update:"
              grep -E "<Version>|<TargetFramework>" src/Directory.Build.props
            fi
            
            # Reset workflow files to avoid including workflow changes in the PR
            echo "üìù Resetting workflow files to ${{ matrix.target_branch }} version..."
            if [ -d ".github/workflows" ]; then
              git checkout ${{ matrix.target_branch }} -- .github/workflows/ || true
            fi

            
            # Stage all changes
            git add -A
            
            # Show what files have changes
            echo "üìã Files with changes after cherry-pick and reset:"
            git diff --cached --name-status
            
            # Show actual changes
            echo "üìù Actual changes to be committed:"
            git diff --cached --stat

            # Check if there are changes to commit
            if git diff --cached --quiet; then
              echo "‚ÑπÔ∏è  No changes to commit after processing"
              echo "This means all changes from main are already in ${{ matrix.target_branch }}"
              echo "or only affected .csproj/Directory.Build.props files which we reset."
              git checkout main
              git branch -D "$sync_branch"
              exit 0
            fi

            # Create a file with commits that need manual merging (if any)
            if [ ${#failed_commits[@]} -gt 0 ]; then
              echo "üìù Creating manual merge file for failed commits..."
              MANUAL_MERGE_FILE="MANUAL_MERGE_COMMITS.md"
              
              cat > "$MANUAL_MERGE_FILE" << EOF
# Commits Requiring Manual Merge

This file lists commits from \`main\` that could not be automatically applied to \`${{ matrix.target_branch }}\` and need manual merging.

## Summary
- **Total commits requiring manual merge:** ${#failed_commits[@]}
- **Target branch:** ${{ matrix.target_branch }}
- **Source branch:** main

## Instructions
1. Review each commit below
2. Manually apply the changes from each commit
3. Ensure .csproj files are preserved from ${{ matrix.target_branch }} branch
4. Test the changes
5. Remove this file once all commits have been merged

## Commits to Merge

EOF
              
              # Add details for each failed commit
              for failed_commit_info in "${failed_commits[@]}"; do
                # Extract commit SHA (remove any suffix like "(csproj-only, ...)")
                commit_sha=$(echo "$failed_commit_info" | cut -d' ' -f1)
                
                # Get commit details from main branch (fetch from origin/main to ensure we have the commit)
                git fetch origin main 2>/dev/null || true
                if git show "$commit_sha" --format="%H%n%an%n%ae%n%ad%n%s%n%b" --no-patch > /tmp/commit_info 2>/dev/null; then
                  commit_full_sha=$(sed -n '1p' /tmp/commit_info)
                  commit_author=$(sed -n '2p' /tmp/commit_info)
                  commit_email=$(sed -n '3p' /tmp/commit_info)
                  commit_date=$(sed -n '4p' /tmp/commit_info)
                  commit_subject=$(sed -n '5p' /tmp/commit_info)
                  commit_body=$(sed -n '6,$p' /tmp/commit_info)
                  
                  # Get list of files changed
                  commit_files=$(git show "$commit_sha" --name-only --format=format: --no-patch 2>/dev/null | grep -v '^$' || echo "N/A")
                  
                  cat >> "$MANUAL_MERGE_FILE" << EOF
### Commit: \`$commit_sha\`

- **Full SHA:** \`$commit_full_sha\`
- **Author:** $commit_author <$commit_email>
- **Date:** $commit_date
- **Subject:** $commit_subject
- **Reason:** $failed_commit_info

#### Commit Message:
\`\`\`
$commit_subject

$commit_body
\`\`\`

#### Files Changed:
\`\`\`
$commit_files
\`\`\`

#### View Commit:
- GitHub: https://github.com/${{ github.repository }}/commit/$commit_full_sha
- Command: \`git show $commit_full_sha\`

#### Apply Manually:
\`\`\`bash
# Option 1: Try cherry-pick (may need conflict resolution)
git cherry-pick $commit_full_sha

# Option 2: Apply diff manually (excluding .csproj files)
git show $commit_full_sha -- . ':!*.csproj' | git apply

# Option 3: Get individual files
git show $commit_full_sha -- <file-path>
\`\`\`

---

EOF
                else
                  # Fallback if we can't get commit details
                  cat >> "$MANUAL_MERGE_FILE" << EOF
### Commit: \`$commit_sha\`

- **Reason:** $failed_commit_info
- **View:** https://github.com/${{ github.repository }}/commit/$commit_sha
- **Command:** \`git show $commit_sha\`

---

EOF
                fi
                rm -f /tmp/commit_info
              done
              
              # Add footer
              cat >> "$MANUAL_MERGE_FILE" << EOF
## Notes
- Remember to preserve .csproj files from ${{ matrix.target_branch }} branch
- Test all changes before removing this file
- Once all commits are merged, delete this file and commit the removal

---
_Generated automatically by branch sync workflow_
EOF
              
              # Add the file to git
              git add "$MANUAL_MERGE_FILE"
              echo "‚úÖ Created $MANUAL_MERGE_FILE with ${#failed_commits[@]} commits requiring manual merge"
              
              # Store failed commits info for PR description
              FAILED_COMMITS_LIST=$(IFS=$'\n'; echo "${failed_commits[*]}")
              echo "failed_commits<<EOF" >> $GITHUB_ENV
              echo "$FAILED_COMMITS_LIST" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            fi

            # Create commit message with summary
            commit_msg="Sync changes from main to ${{ matrix.target_branch }} - Applied ${#successful_commits[@]} commits, updated versions & framework, preserved .csproj files"
            if [ ${#applied_via_diff[@]} -gt 0 ]; then
              commit_msg="$commit_msg

Applied ${#applied_via_diff[@]} commit(s) via alternative method (cherry-pick failed but diff applied successfully)"
            fi
            if [ ${#failed_commits[@]} -gt 0 ]; then
              commit_msg="$commit_msg

‚ö†Ô∏è Note: ${#failed_commits[@]} commit(s) could not be automatically applied. See MANUAL_MERGE_COMMITS.md for details."
            fi

            # Commit the changes
            git commit -m "$commit_msg"

            echo "üì§ Attempting to push sync branch: $sync_branch"
            
            # Try to push to origin, if it fails try to push to a fork
            if git push origin "$sync_branch" 2>/dev/null; then
              echo "‚úÖ Pushed to origin successfully"
              PUSH_REPO="${{ github.repository }}"
            else
              echo "‚ö†Ô∏è Cannot push to origin, trying fork approach..."
              
              # Check if we have a fork configured
              FORK_OWNER="${{ vars.FORK_OWNER || 'arcenox' }}"
              FORK_URL="https://${{ secrets.PAT_TOKEN }}@github.com/${FORK_OWNER}/TickerQ.git"
              
              # Add fork as remote if not exists
              git remote add fork "$FORK_URL" 2>/dev/null || git remote set-url fork "$FORK_URL"
              
              # Push to fork
              if git push fork "$sync_branch"; then
                echo "‚úÖ Pushed to fork: ${FORK_OWNER}/TickerQ"
                PUSH_REPO="${FORK_OWNER}/TickerQ"
              else
                echo "‚ùå Failed to push to both origin and fork"
                exit 1
              fi
            fi

            # Store branch name and repo for PR creation
            echo "sync_branch=$sync_branch" >> $GITHUB_ENV
            echo "push_repo=$PUSH_REPO" >> $GITHUB_ENV
          else
            echo "‚ÑπÔ∏è  No commits to apply"
            git checkout main
            exit 0
          fi

      - name: Ensure labels exist
        if: steps.check_merge.outputs.needs_merge == 'true'
        run: |
          # Create labels if they don't exist (ignore errors if they already exist)
          gh label create "automated" --description "Automated PR" --color "0E8A16" 2>/dev/null || true
          gh label create "sync" --description "Branch synchronization" --color "1D76DB" 2>/dev/null || true
          gh label create "${{ matrix.target_branch }}" --description "Target: ${{ matrix.target_branch }} branch" --color "FEF2C0" 2>/dev/null || true
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Create Pull Request
        if: steps.check_merge.outputs.needs_merge == 'true' && env.sync_branch != ''
        run: |
          # Create PR using GitHub CLI (gh)
          PR_BODY=$(cat << EOF
          ## ü§ñ Automated Branch Sync

          This PR syncs recent changes from \`main\` branch to \`${{ matrix.target_branch }}\`.

          ### Changes Applied:
          - ‚úÖ Applied recent commits from main
          - ‚úÖ Updated version numbers (9.0.x ‚Üí 8.0.x for net8 branch)
          - ‚úÖ Updated target framework (net9.0 ‚Üí net8.0 for net8 branch)
          - ‚úÖ Preserved .csproj files from ${{ matrix.target_branch }} branch

          ### Review Notes:
          - All .csproj files maintain ${{ matrix.target_branch }} configurations
          - Directory.Build.props has been updated for ${{ matrix.target_branch }} compatibility
          - Commits that failed cherry-pick were attempted via alternative methods (diff application, file-by-file)
          - Ready for testing on ${{ matrix.target_branch }} environment
          EOF
          )
          
          # Add failed commits section if any
          if [ -n "${{ env.failed_commits }}" ]; then
            PR_BODY="$PR_BODY

          ### ‚ö†Ô∏è Commits Requiring Manual Review:
          The following commits could not be automatically applied and may need manual review:
          \`\`\`
          ${{ env.failed_commits }}
          \`\`\`
          
          **üìÑ See \`MANUAL_MERGE_COMMITS.md\` file in this PR for detailed instructions and commit information.**
          
          The file includes:
          - Full commit details (author, date, message)
          - List of files changed
          - Direct links to view commits on GitHub
          - Commands to manually apply each commit
          "
          fi
          
          PR_BODY="$PR_BODY

          ---
          _Created automatically by branch sync workflow_"

          # Create PR (from fork if necessary)
          if [ "${{ env.push_repo }}" = "${{ github.repository }}" ]; then
            # Creating PR from same repo
            gh pr create \
              --base "${{ matrix.target_branch }}" \
              --head "${{ env.sync_branch }}" \
              --title "üîÑ Sync main branch changes to ${{ matrix.target_branch }}" \
              --body "$PR_BODY" \
              2>&1 | tee pr_output.txt
          else
            # Creating PR from fork
            FORK_OWNER=$(echo "${{ env.push_repo }}" | cut -d'/' -f1)
            gh pr create \
              --base "${{ matrix.target_branch }}" \
              --head "${FORK_OWNER}:${{ env.sync_branch }}" \
              --repo "${{ github.repository }}" \
              --title "üîÑ Sync main branch changes to ${{ matrix.target_branch }}" \
              --body "$PR_BODY" \
              2>&1 | tee pr_output.txt
          fi
          
          # Extract PR number if created
          PR_NUMBER=$(grep -oP '(?<=pull/)\d+' pr_output.txt || echo "")
          
          if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Created PR #$PR_NUMBER"
            
            # Try to add labels if they exist (ignore errors)
            gh pr edit "$PR_NUMBER" --add-label "automated" 2>/dev/null || true
            gh pr edit "$PR_NUMBER" --add-label "sync" 2>/dev/null || true
            gh pr edit "$PR_NUMBER" --add-label "${{ matrix.target_branch }}" 2>/dev/null || true
            
            echo "üìã PR URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          else
            echo "‚ö†Ô∏è PR might already exist or creation failed. Check if a PR already exists for branch: ${{ env.sync_branch }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Skip notification
        if: steps.check_merge.outputs.needs_merge == 'false'
        run: echo "‚ÑπÔ∏è  No merge needed for ${{ matrix.target_branch }}"

  net8-push-notification:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/net8' && github.actor == 'github-actions[bot]'

    steps:
      - name: Notify about bot push to net8
        run: |
          echo "## ü§ñ Bot Push to net8 Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This push to net8 branch was made by github-actions[bot] as part of the automated sync from main." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What happened:" >> $GITHUB_STEP_SUMMARY
          echo "- Changes from main were merged into net8" >> $GITHUB_STEP_SUMMARY
          echo "- Version numbers updated (9.0.x ‚Üí 8.0.x)" >> $GITHUB_STEP_SUMMARY
          echo "- TargetFramework updated (net9.0 ‚Üí net8.0)" >> $GITHUB_STEP_SUMMARY
          echo "- .csproj files preserved from net8 branch" >> $GITHUB_STEP_SUMMARY

  summary:
    needs: sync-branches
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: Generate summary
        run: |
          echo "## Branch Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.sync-branches.result }}" = "success" ]; then
            echo "‚úÖ All branch sync PRs created successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Some branch syncs failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Review and merge the created PRs" >> $GITHUB_STEP_SUMMARY
          echo "- Test changes on target branches" >> $GITHUB_STEP_SUMMARY
          echo "- Target branches: net8 (and any others in TARGET_BRANCHES variable)" >> $GITHUB_STEP_SUMMARY