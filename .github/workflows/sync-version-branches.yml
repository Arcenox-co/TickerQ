name: Sync Version Branches

on:
  push:
    branches:
      - main
      - net8  # Allows manual pushes to net8 to be visible, but sync logic only runs from main
      - net9  # Allows manual pushes to net9 to be visible, but sync logic only runs from main
  workflow_dispatch:
    inputs:
      target_branches:
        description: 'Comma-separated list of target branches (default: net8,net9)'
        required: false
        default: 'net8,net9'
        type: string
      dry_run:
        description: 'Run without making changes'
        required: false
        default: false
        type: boolean

jobs:
  sync-branches:
    runs-on: ubuntu-latest

    permissions:
      contents: write      # Required to push commits to the repository
      pull-requests: write # Required to create pull requests
      issues: write        # Required to create and manage labels

    # Only run sync logic when triggered from main branch (prevents infinite loops)
    if: github.ref == 'refs/heads/main'

    strategy:
      matrix:
        target_branch: ${{ fromJSON(vars.TARGET_BRANCHES || '["net8","net9"]') }}
      fail-fast: false

    steps:
      - name: Check PAT_TOKEN exists
        run: |
          if [ -z "${{ secrets.PAT_TOKEN }}" ]; then
            echo "‚ùå ERROR: PAT_TOKEN secret is not configured!"
            echo "Please add a Personal Access Token with 'repo' scope to repository secrets."
            echo "Go to: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret"
            echo "Name: PAT_TOKEN"
            echo "Value: Your GitHub Personal Access Token"
            exit 1
          fi
          echo "‚úÖ PAT_TOKEN is configured"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}
          persist-credentials: true

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Configure git to use the PAT for authentication
          git config --global url."https://${{ secrets.PAT_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: Extract target branches from input
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ -n "${{ github.event.inputs.target_branches }}" ]; then
            echo "TARGET_BRANCHES=[$(echo '${{ github.event.inputs.target_branches }}' | sed 's/,/","/g' | sed 's/^/"/;s/$/"/')]" >> $GITHUB_ENV
          fi

      - name: Check if merge is needed
        id: check_merge
        run: |
          echo "üîç Checking if merge is needed for ${{ matrix.target_branch }}"

          # Check if target branch exists
          if ! git ls-remote --heads origin ${{ matrix.target_branch }} | grep -q ${{ matrix.target_branch }}; then
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå Target branch ${{ matrix.target_branch }} does not exist"
            exit 0
          fi

          # Check if main has new commits
          git checkout main
          git checkout ${{ matrix.target_branch }}

          if git merge-base --is-ancestor main ${{ matrix.target_branch }}; then
            echo "needs_merge=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No new commits to merge"
          else
            echo "needs_merge=true" >> $GITHUB_OUTPUT
            echo "‚úÖ New commits found, merge needed"
          fi

      - name: Create sync branch and apply changes
        if: steps.check_merge.outputs.needs_merge == 'true'
        run: |
          echo "üîÑ Creating sync branch from ${{ matrix.target_branch }}"

          # Create a new branch for the PR
          sync_branch="sync-main-to-${{ matrix.target_branch }}-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$sync_branch" ${{ matrix.target_branch }}

          # Get ALL commits that need to be applied (including merge commits)
          # First, get the merge base to ensure we have the correct starting point
          merge_base=$(git merge-base ${{ matrix.target_branch }} main)
          echo "üìç Merge base: $merge_base"
          
          # Get all commits in main that are not in target branch (including merges)
          # Store commits in a temp file to avoid subshell issues
          git log "$merge_base..main" --format="%H" --reverse > /tmp/commits_to_apply.txt
          
          # Also get commits using the simpler range (as fallback)
          if [ ! -s /tmp/commits_to_apply.txt ]; then
            git log "${{ matrix.target_branch }}..main" --format="%H" --reverse > /tmp/commits_to_apply.txt
          fi

          if [ -s /tmp/commits_to_apply.txt ]; then
            echo "üìã Found commits to apply:"
            while read commit; do
              commit_msg=$(git log -1 --format="%s" "$commit")
              echo "  - $commit: $commit_msg"
            done < /tmp/commits_to_apply.txt
            
            # Filter out commits that are already in the target branch
            echo "üîç Filtering out commits already in ${{ matrix.target_branch }} branch..."
            filtered_commits_file="/tmp/filtered_commits.txt"
            touch "$filtered_commits_file"
            
            successful_count=0
            failed_count=0
            ignored_count=0
            already_applied_count=0
            # Track ignored commits in array (no file needed)
            declare -a ignored_commits_array=()
            
            # Cherry-pick each commit individually, but first check if it's already in target branch
            while read commit; do
              commit_msg=$(git log -1 --format="%s" "$commit")
              commit_full_msg=$(git log -1 --format="%B" "$commit")
              
              # Check if commit is already in target branch
              if git branch --contains "$commit" | grep -q "${{ matrix.target_branch }}"; then
                echo "‚è≠Ô∏è  Commit $commit already in ${{ matrix.target_branch }}, skipping: $commit_msg"
                already_applied_count=$((already_applied_count + 1))
                continue
              fi
              
              # Check if commit should be ignored (check for ignore patterns in commit message)
              # Patterns: [skip-sync], [no-sync], [ignore-sync], [skip-branch-sync]
              if echo "$commit_msg" | grep -qiE '\[(skip-sync|no-sync|ignore-sync|skip-branch-sync)\]' || \
                 echo "$commit_full_msg" | grep -qiE '\[(skip-sync|no-sync|ignore-sync|skip-branch-sync)\]'; then
                echo "‚è≠Ô∏è  Skipping ignored commit $commit: $commit_msg"
                ignored_commits_array+=("$commit")
                ignored_count=$((ignored_count + 1))
                continue
              fi
              
              echo "$commit" >> "$filtered_commits_file"
            done < /tmp/commits_to_apply.txt
            
            # Now cherry-pick only the filtered commits
            if [ -s "$filtered_commits_file" ]; then
              echo "üçí Processing commits (skipped ${already_applied_count} already in branch, ${ignored_count} ignored)..."
              while read commit; do
                commit_msg=$(git log -1 --format="%s" "$commit")
                echo "üçí Cherry-picking $commit: $commit_msg"
                
                # Try cherry-pick with conflict resolution
                if git cherry-pick --no-commit "$commit" 2>&1; then
                  echo "‚úÖ Cherry-pick successful for $commit"
                  successful_count=$((successful_count + 1))
                else
                  # Check if it's already applied (empty commit)
                  if git diff --cached --quiet && git diff --quiet; then
                    # Empty commit, already applied
                    echo "‚ÑπÔ∏è  Commit $commit already applied (empty), skipping..."
                    git cherry-pick --abort || true
                    already_applied_count=$((already_applied_count + 1))
                  else
                    # Has conflicts or other issues, skip this commit
                    echo "‚ö†Ô∏è  Conflicts or issues with $commit, skipping..."
                    git cherry-pick --abort || true
                    failed_count=$((failed_count + 1))
                  fi
                fi
              done < "$filtered_commits_file"
            else
              echo "‚ÑπÔ∏è  No new commits to cherry-pick (all commits already in branch or ignored)"
            fi
            
            echo "üìä Summary: $successful_count successful cherry-picks, $failed_count failed, $already_applied_count already in branch, $ignored_count ignored"
            
            # Show ignored commits if any
            if [ ${#ignored_commits_array[@]} -gt 0 ]; then
              echo "‚è≠Ô∏è  Ignored commits (marked with [skip-sync], [no-sync], [ignore-sync], or [skip-branch-sync]):"
              for commit in "${ignored_commits_array[@]}"; do
                commit_msg=$(git log -1 --format="%s" "$commit" 2>/dev/null || echo "unknown")
                echo "  - $commit: $commit_msg"
              done
            fi
          else
            # No commits found to apply
            echo "‚ÑπÔ∏è  No commits found to apply - branches may already be in sync"
            git checkout main
            git branch -D "$sync_branch" 2>/dev/null || true
            exit 0
          fi
          
          # Reset files that should stay as they are in the target branch
          # (This runs for both the if and else branches above)
          echo "üìù Processing configuration files..."
          
          # Reset all .csproj files
          find . -name "*.csproj" -type f -exec git checkout ${{ matrix.target_branch }} -- {} \;
          
          # Get Directory.Build.props from main and update it for target branch
          # Main is now net10, so we convert 10.x.x ‚Üí target version
          if [ -f "src/Directory.Build.props" ]; then
            echo "üìù Getting Directory.Build.props from main and updating for ${{ matrix.target_branch }}..."
            
            # Explicitly get the file from main branch
            git checkout main -- src/Directory.Build.props
            
            # Get the target .NET version
            dotnet_version=$(echo "${{ matrix.target_branch }}" | sed 's/[^0-9]*//g')
            
            # Show current state from main
            echo "Directory.Build.props from main (before update):"
            grep -E "<Version>|<TargetFramework>" src/Directory.Build.props
            
            # Update version (10.x.x ‚Üí target.x.x) keeping the same minor/patch/suffix
            # Main is net10, so we convert from 10.x.x to the target version
            current_version=$(grep -oP '<Version>\K[^<]+' src/Directory.Build.props)
            new_version=$(echo "$current_version" | sed "s/^10\./$dotnet_version./")
            sed -i "s|<Version>$current_version</Version>|<Version>$new_version</Version>|g" src/Directory.Build.props
            
            # Update target framework (net10.0 ‚Üí net{target}.0)
            sed -i "s|<TargetFramework>net10\.0</TargetFramework>|<TargetFramework>net$dotnet_version.0</TargetFramework>|g" src/Directory.Build.props
            
            echo "Directory.Build.props after update:"
            grep -E "<Version>|<TargetFramework>" src/Directory.Build.props
          fi
          
          # Reset workflow files to avoid including workflow changes in the PR
          echo "üìù Resetting workflow files to ${{ matrix.target_branch }} version..."
          if [ -d ".github/workflows" ]; then
            git checkout ${{ matrix.target_branch }} -- .github/workflows/ || true
          fi

          
          # Stage all changes
          git add -A
          
          # Show what files have changes
          echo "üìã Files with changes after cherry-pick and reset:"
          git diff --cached --name-status
          
          # Show actual changes
          echo "üìù Actual changes to be committed:"
          git diff --cached --stat

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit after processing"
            echo "This means all changes from main are already in ${{ matrix.target_branch }}"
            echo "or only affected .csproj/Directory.Build.props files which we reset."
            git checkout main
            git branch -D "$sync_branch"
            exit 0
          fi

          # Commit the changes
          git commit -m "Sync changes from main to ${{ matrix.target_branch }} - Applied recent commits, updated versions & framework, preserved .csproj files"

          echo "üì§ Attempting to push sync branch: $sync_branch"
          
          # Try to push to origin, if it fails try to push to a fork
          if git push origin "$sync_branch" 2>/dev/null; then
            echo "‚úÖ Pushed to origin successfully"
            PUSH_REPO="${{ github.repository }}"
          else
            echo "‚ö†Ô∏è Cannot push to origin, trying fork approach..."
            
            # Check if we have a fork configured
            FORK_OWNER="${{ vars.FORK_OWNER || 'arcenox' }}"
            FORK_URL="https://${{ secrets.PAT_TOKEN }}@github.com/${FORK_OWNER}/TickerQ.git"
            
            # Add fork as remote if not exists
            git remote add fork "$FORK_URL" 2>/dev/null || git remote set-url fork "$FORK_URL"
            
            # Push to fork
            if git push fork "$sync_branch"; then
              echo "‚úÖ Pushed to fork: ${FORK_OWNER}/TickerQ"
              PUSH_REPO="${FORK_OWNER}/TickerQ"
            else
              echo "‚ùå Failed to push to both origin and fork"
              exit 1
            fi
          fi

          # Store branch name and repo for PR creation
          echo "sync_branch=$sync_branch" >> $GITHUB_ENV
          echo "push_repo=$PUSH_REPO" >> $GITHUB_ENV

      - name: Ensure labels exist
        if: steps.check_merge.outputs.needs_merge == 'true'
        run: |
          # Create labels if they don't exist (ignore errors if they already exist)
          gh label create "automated" --description "Automated PR" --color "0E8A16" 2>/dev/null || true
          gh label create "sync" --description "Branch synchronization" --color "1D76DB" 2>/dev/null || true
          gh label create "${{ matrix.target_branch }}" --description "Target: ${{ matrix.target_branch }} branch" --color "FEF2C0" 2>/dev/null || true
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Create Pull Request
        if: steps.check_merge.outputs.needs_merge == 'true' && env.sync_branch != ''
        run: |
          # Get the target .NET version number for display
          dotnet_version=$(echo "${{ matrix.target_branch }}" | sed 's/[^0-9]*//g')
          
          # Create PR using GitHub CLI (gh)
          PR_BODY=$(cat << EOF
          ## ü§ñ Automated Branch Sync

          This PR syncs recent changes from \`main\` branch to \`${{ matrix.target_branch }}\`.

          ### Changes Applied:
          - ‚úÖ Applied recent commits from main (using cherry-pick)
          - ‚úÖ Updated version numbers (10.x.x ‚Üí ${dotnet_version}.x.x)
          - ‚úÖ Updated target framework (net10.0 ‚Üí net${dotnet_version}.0)
          - ‚úÖ Preserved .csproj files from ${{ matrix.target_branch }} branch
          - ‚è≠Ô∏è Commits marked with \`[skip-sync]\`, \`[no-sync]\`, \`[ignore-sync]\`, or \`[skip-branch-sync]\` were excluded

          ### Review Notes:
          - All .csproj files maintain ${{ matrix.target_branch }} configurations
          - Directory.Build.props has been updated for ${{ matrix.target_branch }} compatibility
          - Ready for testing on ${{ matrix.target_branch }} environment

          ---
          _Created automatically by branch sync workflow_
          EOF
          )

          # Create PR (from fork if necessary)
          if [ "${{ env.push_repo }}" = "${{ github.repository }}" ]; then
            # Creating PR from same repo
            gh pr create \
              --base "${{ matrix.target_branch }}" \
              --head "${{ env.sync_branch }}" \
              --title "üîÑ Sync main branch changes to ${{ matrix.target_branch }}" \
              --body "$PR_BODY" \
              2>&1 | tee pr_output.txt
          else
            # Creating PR from fork
            FORK_OWNER=$(echo "${{ env.push_repo }}" | cut -d'/' -f1)
            gh pr create \
              --base "${{ matrix.target_branch }}" \
              --head "${FORK_OWNER}:${{ env.sync_branch }}" \
              --repo "${{ github.repository }}" \
              --title "üîÑ Sync main branch changes to ${{ matrix.target_branch }}" \
              --body "$PR_BODY" \
              2>&1 | tee pr_output.txt
          fi
          
          # Extract PR number if created
          PR_NUMBER=$(grep -oP '(?<=pull/)\d+' pr_output.txt || echo "")
          
          if [ -n "$PR_NUMBER" ]; then
            echo "‚úÖ Created PR #$PR_NUMBER"
            
            # Try to add labels if they exist (ignore errors)
            gh pr edit "$PR_NUMBER" --add-label "automated" 2>/dev/null || true
            gh pr edit "$PR_NUMBER" --add-label "sync" 2>/dev/null || true
            gh pr edit "$PR_NUMBER" --add-label "${{ matrix.target_branch }}" 2>/dev/null || true
            
            echo "üìã PR URL: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          else
            echo "‚ö†Ô∏è PR might already exist or creation failed. Check if a PR already exists for branch: ${{ env.sync_branch }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Skip notification
        if: steps.check_merge.outputs.needs_merge == 'false'
        run: echo "‚ÑπÔ∏è  No merge needed for ${{ matrix.target_branch }}"

  net8-push-notification:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/net8' && github.actor == 'github-actions[bot]'

    steps:
      - name: Notify about bot push to net8
        run: |
          echo "## ü§ñ Bot Push to net8 Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This push to net8 branch was made by github-actions[bot] as part of the automated sync from main." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What happened:" >> $GITHUB_STEP_SUMMARY
          echo "- Changes from main were merged into net8" >> $GITHUB_STEP_SUMMARY
          echo "- Version numbers updated (10.x.x ‚Üí 8.x.x)" >> $GITHUB_STEP_SUMMARY
          echo "- TargetFramework updated (net10.0 ‚Üí net8.0)" >> $GITHUB_STEP_SUMMARY
          echo "- .csproj files preserved from net8 branch" >> $GITHUB_STEP_SUMMARY

  net9-push-notification:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/net9' && github.actor == 'github-actions[bot]'

    steps:
      - name: Notify about bot push to net9
        run: |
          echo "## ü§ñ Bot Push to net9 Detected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This push to net9 branch was made by github-actions[bot] as part of the automated sync from main." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What happened:" >> $GITHUB_STEP_SUMMARY
          echo "- Changes from main were merged into net9" >> $GITHUB_STEP_SUMMARY
          echo "- Version numbers updated (10.x.x ‚Üí 9.x.x)" >> $GITHUB_STEP_SUMMARY
          echo "- TargetFramework updated (net10.0 ‚Üí net9.0)" >> $GITHUB_STEP_SUMMARY
          echo "- .csproj files preserved from net9 branch" >> $GITHUB_STEP_SUMMARY

  summary:
    needs: sync-branches
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: Generate summary
        run: |
          echo "## Branch Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.sync-branches.result }}" = "success" ]; then
            echo "‚úÖ All branch sync PRs created successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Some branch syncs failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Review and merge the created PRs" >> $GITHUB_STEP_SUMMARY
          echo "- Test changes on target branches" >> $GITHUB_STEP_SUMMARY
          echo "- Target branches: net8, net9 (and any others in TARGET_BRANCHES variable)" >> $GITHUB_STEP_SUMMARY